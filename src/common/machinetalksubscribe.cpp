/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "machinetalksubscribe.h"
#include "debughelper.h"

/** Generic Machinetalk Subscribe implementation */
MachinetalkSubscribe::MachinetalkSubscribe(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_socketUri(""),
    m_debugName(""),
    m_context(NULL),
    m_socket(NULL),
    m_state(Down),
    m_fsm(NULL),
    m_errorString("")
    ,m_heartbeatTimer(new QTimer(this)),
    m_heartbeatPeriod(0),
    m_heartbeatErrorCount(0),
    m_heartbeatErrorThreshold(2)
{

    m_heartbeatTimer->setSingleShot(true);
    connect(m_heartbeatTimer, SIGNAL(timeout()), this, SLOT(heartbeatTimerTick()));

    m_fsm = new QStateMachine(parent);
    QState *downState = new QState(m_fsm);
    connect(downState, SIGNAL(entered()), this, SLOT(fsmDownEntered()));
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, SIGNAL(entered()), this, SLOT(fsmTryingEntered()));
    QState *upState = new QState(m_fsm);
    connect(upState, SIGNAL(entered()), this, SLOT(fsmUpEntered()));
    m_fsm->setInitialState(downState);
    m_fsm->start();

    downState->addTransition(this, SIGNAL(fsmConnect()), tryingState);
    tryingState->addTransition(this, SIGNAL(fsmConnected()), upState);
    tryingState->addTransition(this, SIGNAL(fsmDisconnect()), downState);
    upState->addTransition(this, SIGNAL(fsmTimeout()), tryingState);
    upState->addTransition(this, SIGNAL(fsmDisconnect()), downState);

    connect(this, SIGNAL(fsmConnect()), this, SLOT(connectSockets()));
    connect(this, SIGNAL(fsmConnect()), this, SLOT(subscribe()));
    connect(this, SIGNAL(fsmConnected()), this, SLOT(resetHeartbeatError()));
    connect(this, SIGNAL(fsmConnected()), this, SLOT(startHeartbeatTimer()));
    connect(this, SIGNAL(fsmDisconnect()), this, SLOT(stopHeartbeatTimer()));
    connect(this, SIGNAL(fsmDisconnect()), this, SLOT(disconnectSockets()));
    connect(this, SIGNAL(fsmTimeout()), this, SLOT(stopHeartbeatTimer()));
    connect(this, SIGNAL(fsmTimeout()), this, SLOT(disconnectSockets()));
    connect(this, SIGNAL(fsmTimeout()), this, SLOT(connectSockets()));
    connect(this, SIGNAL(fsmTimeout()), this, SLOT(subscribe()));

    m_context = new SocketNotifierZMQContext(this, 1);
    connect(m_context, SIGNAL(notifierError(int,QString)),
            this, SLOT(socketError(int,QString)));
    m_context->start();
}

MachinetalkSubscribe::~MachinetalkSubscribe()
{
    if (m_ready)
    {
        stop();
    }

    if (m_context != NULL)
    {
        m_context->stop();
        m_context->deleteLater();
        m_context = NULL;
    }
}

/** Add a topic that should be subscribed **/
void MachinetalkSubscribe::addSocketTopic(const QString &name)
{
    m_socketTopics.insert(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void MachinetalkSubscribe::removeSocketTopic(const QString &name)
{
    m_socketTopics.remove(name);
}

/** Clears the the topics that should be subscribed **/
void MachinetalkSubscribe::clearSocketTopics()
{
    m_socketTopics.clear();
}

/** Connects the 0MQ sockets */
bool MachinetalkSubscribe::connectSockets()
{
    m_socket = m_context->createSocket(ZMQSocket::TYP_SUB, this);
    m_socket->setLinger(0);

    try {
        m_socket->connectTo(m_socketUri);
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString);
        return false;
    }

    connect(m_socket, SIGNAL(messageReceived(QList<QByteArray>)),
            this, SLOT(socketMessageReceived(QList<QByteArray>)));

#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "sockets connected" << m_socketUri);
#endif

    return true;
}

/** Disconnects the 0MQ sockets */
void MachinetalkSubscribe::disconnectSockets()
{
    if (m_socket != NULL)
    {
        m_socket->close();
        m_socket->deleteLater();
        m_socket = NULL;
    }
}

void MachinetalkSubscribe::subscribe()
{
    foreach(QString topic, m_socketTopics)
    {
        m_socket->subscribeTo(topic.toLocal8Bit());
    }
}

void MachinetalkSubscribe::start()
{
#ifdef QT_DEBUG
   DEBUG_TAG(1, m_debugName, "start");
#endif

   emit fsmConnect();
}

void MachinetalkSubscribe::stop()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "stop");
#endif

    emit fsmDisconnect();
}

void MachinetalkSubscribe::resetHeartbeatError()
{
    m_heartbeatErrorCount = 0;
}

void MachinetalkSubscribe::resetHeartbeatTimer()
{
    if (m_heartbeatTimer->isActive())
    {
        m_heartbeatTimer->stop();
    }

    if (m_heartbeatPeriod > 0)
    {
        m_heartbeatTimer->setInterval(m_heartbeatPeriod);
        m_heartbeatTimer->start();
    }
}

void MachinetalkSubscribe::startHeartbeatTimer()
{
    resetHeartbeatTimer();
}

void MachinetalkSubscribe::stopHeartbeatTimer()
{
    m_heartbeatTimer->stop();
}

void MachinetalkSubscribe::heartbeatTimerTick()
{

    m_heartbeatErrorCount += 1;

    if (m_heartbeatErrorCount > m_heartbeatErrorThreshold)
    {
         if (m_state == Up)
         {
             emit fsmTimeout();
         }
    }
}

/** Processes all message received on the 0MQ socket */
void MachinetalkSubscribe::socketMessageReceived(QList<QByteArray> messageList)
{
    pb::Container *rx = &m_socketRx;
    QByteArray topic;

    if (messageList.length() < 2)  // in case we received insufficient data
    {
        return;
    }

    // we only handle the first two messges
    topic = messageList.at(0);
    rx->ParseFromArray(messageList.at(1).data(), messageList.at(1).size());

#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(*rx, &s);
    DEBUG_TAG(3, m_debugName, "server message" << QString::fromStdString(s));
#endif

    // react to any incoming message
    resetHeartbeatTimer();

    // react to ping message
    if (rx->type() == pb::MT_PING)
    {
        return;
    }

    // react to full update message
    if (rx->type() == pb::MT_HALRCOMP_FULL_UPDATE)
    {
        if (rx->has_pparams())
        {
            pb::ProtocolParameters pparams = rx->pparams();
            m_heartbeatPeriod = pparams.keepalive_timer();
        }
        if (m_state == Trying)
        {
            emit fsmConnected();
        }
    }

    emit socketMessageReceived(topic, rx);
}

void MachinetalkSubscribe::socketError(int errorNum, const QString &errorMsg)
{
    QString errorString;
    errorString = QString("Error %1: ").arg(errorNum) + errorMsg;
    //updateState(SocketError, errorString);
}

void MachinetalkSubscribe::fsmDownEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "DOWN");
#endif
    m_state = Down;
    emit stateChanged(m_state);
}

void MachinetalkSubscribe::fsmTryingEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "TRYING");
#endif
    m_state = Trying;
    emit stateChanged(m_state);
}

void MachinetalkSubscribe::fsmUpEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "UP");
#endif
    m_state = Up;
    emit stateChanged(m_state);
}
