/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "halremotecomponentbase.h"
#include "debughelper.h"

/** Generic HAL Remote Component Base implementation */
HalRemoteComponentBase::HalRemoteComponentBase(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_socketUri(""),
    m_debugName(""),
    m_halrcmdChannel(NULL),
    m_halrcompChannel(NULL),
    m_state(Down),
    m_fsm(NULL),
    m_errorString("")
{
    // initialize halrcmd channel
    m_halrcmdChannel = new MachinetalkRpcClient(this);
    connect(m_halrcmdChannel, SIGNAL(socketUriChanged(QString)),
            this, SIGNAL(halrcmdUriChanged(QString)));
    connect(m_halrcmdChannel, SIGNAL(stateChanged(MachinetalkRpcClient::State)),
            this, SLOT(halrcmdChannelStateChanged(MachinetalkRpcClient::State)));
    connect(m_halrcmdChannel, SIGNAL(socketMessageReceived(pb::Container*)),
            this, SLOT(halrcmdChannelMessageReceived(pb::Container*)));
    // initialize halrcomp channel
    m_halrcompChannel = new MachinetalkSubscribe(this);
    connect(m_halrcompChannel, SIGNAL(socketUriChanged(QString)),
            this, SIGNAL(halrcompUriChanged(QString)));
    connect(m_halrcompChannel, SIGNAL(stateChanged(MachinetalkSubscribe::State)),
            this, SLOT(halrcompChannelStateChanged(MachinetalkSubscribe::State)));
    connect(m_halrcompChannel, SIGNAL(socketMessageReceived(QByteArray, pb::Container*)),
            this, SLOT(halrcompChannelMessageReceived(QByteArray, pb::Container*)));

    m_fsm = new QStateMachine(parent);
    QState *downState = new QState(m_fsm);
    connect(downState, SIGNAL(entered()), this, SLOT(fsmDownEntered()));
    QState *tryingState = new QState(m_fsm);
    connect(tryingState, SIGNAL(entered()), this, SLOT(fsmTryingEntered()));
    QState *bindingState = new QState(m_fsm);
    connect(bindingState, SIGNAL(entered()), this, SLOT(fsmBindingEntered()));
    QState *syncingState = new QState(m_fsm);
    connect(syncingState, SIGNAL(entered()), this, SLOT(fsmSyncingEntered()));
    QState *syncedState = new QState(m_fsm);
    connect(syncedState, SIGNAL(entered()), this, SLOT(fsmSyncedEntered()));
    QState *errorState = new QState(m_fsm);
    connect(errorState, SIGNAL(entered()), this, SLOT(fsmErrorEntered()));
    m_fsm->setInitialState(downState);
    m_fsm->start();

    downState->addTransition(this, SIGNAL(fsmConnect()), tryingState);
    tryingState->addTransition(this, SIGNAL(fsmHalrcmdUp()), bindingState);
    tryingState->addTransition(this, SIGNAL(fsmDisconnect()), downState);
    bindingState->addTransition(this, SIGNAL(fsmBindConfirmed()), syncingState);
    bindingState->addTransition(this, SIGNAL(fsmBindRejected()), errorState);
    bindingState->addTransition(this, SIGNAL(fsmDisconnect()), downState);
    syncingState->addTransition(this, SIGNAL(fsmHalrcmdTrying()), tryingState);
    syncingState->addTransition(this, SIGNAL(fsmHalrcompUp()), syncedState);
    syncingState->addTransition(this, SIGNAL(fsmDisconnect()), downState);
    syncedState->addTransition(this, SIGNAL(fsmHalrcompTrying()), syncingState);
    syncedState->addTransition(this, SIGNAL(fsmHalrcmdTrying()), tryingState);
    syncedState->addTransition(this, SIGNAL(fsmDisconnect()), downState);
    errorState->addTransition(this, SIGNAL(fsmDisconnect()), downState);

    connect(this, SIGNAL(fsmConnect()), this, SLOT(addPins()));
    connect(this, SIGNAL(fsmConnect()), this, SLOT(startHalrcmdChannel()));
    connect(this, SIGNAL(fsmHalrcmdUp()), this, SLOT(bind()));
    connect(this, SIGNAL(fsmDisconnect()), this, SLOT(stopHalrcmdChannel()));
    connect(this, SIGNAL(fsmDisconnect()), this, SLOT(stopHalrcompChannel()));
    connect(this, SIGNAL(fsmDisconnect()), this, SLOT(removePins()));
    connect(this, SIGNAL(fsmBindConfirmed()), this, SLOT(startHalrcompChannel()));
    connect(this, SIGNAL(fsmBindRejected()), this, SLOT(stopHalrcompChannel()));
    connect(this, SIGNAL(fsmHalrcmdTrying()), this, SLOT(stopHalrcompChannel()));
    connect(this, SIGNAL(fsmHalrcompUp()), this, SLOT(synced()));
    connect(this, SIGNAL(fsmHalrcompTrying()), this, SLOT(unsyncPins()));
}

HalRemoteComponentBase::~HalRemoteComponentBase()
{
    if (m_ready)
    {
        stop();
    }
}

/** Add a topic that should be subscribed **/
void HalRemoteComponentBase::addHalrcompTopic(const QString &name)
{
    m_halrcompChannel->addSocketTopic(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void HalRemoteComponentBase::removeHalrcompTopic(const QString &name)
{
    m_halrcompChannel->removeSocketTopic(name);
}

/** Clears the the topics that should be subscribed **/
void HalRemoteComponentBase::clearHalrcompTopics()
{
    m_halrcompChannel->clearSocketTopics();
}

void HalRemoteComponentBase::start()
{
#ifdef QT_DEBUG
   DEBUG_TAG(1, m_debugName, "start");
#endif

   emit fsmConnect();
}

void HalRemoteComponentBase::stop()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "stop");
#endif

    emit fsmDisconnect();
}

void HalRemoteComponentBase::startHalrcmdChannel()
{
    m_halrcmdChannel->setReady(true);
}

void HalRemoteComponentBase::stopHalrcmdChannel()
{
    m_halrcmdChannel->setReady(false);
}

void HalRemoteComponentBase::startHalrcompChannel()
{
    m_halrcompChannel->setReady(true);
}

void HalRemoteComponentBase::stopHalrcompChannel()
{
    m_halrcompChannel->setReady(false);
}

/** Processes all message received on the 0MQ socket */
void HalRemoteComponentBase::halrcmdChannelMessageReceived(pb::Container *rx)
{

    // react to halrcomp bind confirm message
    if (rx->type() == pb::MT_HALRCOMP_BIND_CONFIRM)
    {
        if (m_state == Binding)
        {
            emit fsmBindConfirmed();
        }
    }

    emit halrcmdMessageReceived(rx);
}

void HalRemoteComponentBase::sendHalrcmdMessage(pb::ContainerType type, pb::Container *tx)
{
    m_halrcmdChannel->sendSocketMessage(type, tx);
}

void HalRemoteComponentBase::sendHalrcompBind(pb::Container *tx)
{
    sendHalrcmdMessage(pb::MT_HALRCOMP_BIND, tx);
}

void HalRemoteComponentBase::sendHalrcompSet(pb::Container *tx)
{
    sendHalrcmdMessage(pb::MT_HALRCOMP_SET, tx);
}

/** Processes all message received on the 0MQ socket */
void HalRemoteComponentBase::halrcompChannelMessageReceived(const QByteArray &topic, pb::Container *rx)
{

    emit halrcompMessageReceived(topic, rx);
}

void HalRemoteComponentBase::fsmDownEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "DOWN");
#endif
    m_state = Down;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::fsmTryingEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "TRYING");
#endif
    m_state = Trying;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::fsmBindingEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "BINDING");
#endif
    m_state = Binding;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::fsmSyncingEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "SYNCING");
#endif
    m_state = Syncing;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::fsmSyncedEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "SYNCED");
#endif
    m_state = Synced;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::fsmErrorEntered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "ERROR");
#endif
    m_state = Error;
    emit stateChanged(m_state);
}

void HalRemoteComponentBase::halrcmdChannelStateChanged(MachinetalkRpcClient::State state)
{

    if (state == MachinetalkRpcClient::Trying)
    {
        if (m_state == Syncing)
        {
            emit fsmHalrcmdTrying();
        }
        if (m_state == Synced)
        {
            emit fsmHalrcmdTrying();
        }
    }

    if (state == MachinetalkRpcClient::Up)
    {
        if (m_state == Trying)
        {
            emit fsmHalrcmdUp();
        }
    }
}

void HalRemoteComponentBase::halrcompChannelStateChanged(MachinetalkSubscribe::State state)
{

    if (state == MachinetalkSubscribe::Trying)
    {
        if (m_state == Synced)
        {
            emit fsmHalrcompTrying();
        }
    }

    if (state == MachinetalkSubscribe::Up)
    {
        if (m_state == Syncing)
        {
            emit fsmHalrcompUp();
        }
    }
}
